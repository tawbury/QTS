# Design: QTS 아키텍처 고도화 — Phase 1

> Event Priority Architecture + System State Promotion Architecture 구현 설계

## 1. 설계 범위

Phase 1에서 구현하는 2개 서브 아키텍처:
- **17_Event_Priority_Architecture**: P0~P3 이벤트 우선순위 시스템
- **18_System_State_Promotion_Architecture**: AGGRESSIVE/BALANCED/DEFENSIVE 운영 상태

## 2. 패키지 구조

```
src/
├── event/                          # 신규: 이벤트 우선순위 시스템
│   ├── __init__.py
│   ├── contracts.py                # 이벤트 데이터 계약
│   ├── priority.py                 # EventPriority enum, 우선순위 정의
│   ├── queue.py                    # 각 레벨별 큐 구현
│   ├── dispatcher.py               # EventDispatcher (라우팅 + 핸들러 관리)
│   ├── handlers.py                 # 우선순위별 핸들러
│   ├── monitoring.py               # 큐 깊이/레이턴시 모니터링
│   └── config.py                   # 이벤트 시스템 설정
│
├── state/                          # 신규: 운영 상태 관리
│   ├── __init__.py
│   ├── contracts.py                # 운영 상태 데이터 계약
│   ├── operating_state.py          # OperatingState enum + Manager
│   ├── transition.py               # 상태 전환 규칙 엔진
│   ├── override.py                 # 수동 오버라이드 관리
│   ├── properties.py               # 상태별 속성 정의
│   └── config.py                   # 운영 상태 설정
│
└── safety/
    └── state.py                    # 기존: SafetyStateManager (수정 없음)
```

## 3. Event Priority Architecture 상세 설계

### 3.1 데이터 계약 (`src/event/contracts.py`)

```python
from dataclasses import dataclass, field
from enum import IntEnum
from typing import Any, Optional
from datetime import datetime
import uuid

class EventPriority(IntEnum):
    """이벤트 우선순위 레벨"""
    P0_CRITICAL = 0    # Execution & Fill (<10ms)
    P1_HIGH = 1        # Market Data (<50ms)
    P2_MEDIUM = 2      # Strategy (<500ms)
    P3_LOW = 3         # UI & Logging (best-effort)

class EventType(str, Enum):
    """이벤트 타입 정의"""
    # P0: Execution & Fill
    FILL_CONFIRMED = "FILL_CONFIRMED"
    FILL_PARTIAL = "FILL_PARTIAL"
    ORDER_REJECTED = "ORDER_REJECTED"
    ORDER_CANCELLED = "ORDER_CANCELLED"
    POSITION_UPDATE = "POSITION_UPDATE"
    EMERGENCY_STOP = "EMERGENCY_STOP"
    BROKER_DISCONNECT = "BROKER_DISCONNECT"

    # P1: Market Data
    PRICE_TICK = "PRICE_TICK"
    ORDERBOOK_UPDATE = "ORDERBOOK_UPDATE"
    VOLUME_UPDATE = "VOLUME_UPDATE"
    INDEX_UPDATE = "INDEX_UPDATE"
    VIX_UPDATE = "VIX_UPDATE"

    # P2: Strategy
    ETEDA_CYCLE_START = "ETEDA_CYCLE_START"
    STRATEGY_EVALUATE = "STRATEGY_EVALUATE"
    RISK_EVALUATE = "RISK_EVALUATE"
    PORTFOLIO_EVALUATE = "PORTFOLIO_EVALUATE"
    INDICATOR_UPDATE = "INDICATOR_UPDATE"
    SIGNAL_GENERATED = "SIGNAL_GENERATED"

    # P3: UI & Logging
    DASHBOARD_UPDATE = "DASHBOARD_UPDATE"
    LOG_WRITE = "LOG_WRITE"
    REPORT_GENERATE = "REPORT_GENERATE"
    NOTIFICATION_SEND = "NOTIFICATION_SEND"
    METRIC_RECORD = "METRIC_RECORD"

# EventType → Priority 매핑
EVENT_PRIORITY_MAP: dict[EventType, EventPriority] = {
    EventType.FILL_CONFIRMED: EventPriority.P0_CRITICAL,
    EventType.FILL_PARTIAL: EventPriority.P0_CRITICAL,
    EventType.ORDER_REJECTED: EventPriority.P0_CRITICAL,
    EventType.ORDER_CANCELLED: EventPriority.P0_CRITICAL,
    EventType.POSITION_UPDATE: EventPriority.P0_CRITICAL,
    EventType.EMERGENCY_STOP: EventPriority.P0_CRITICAL,
    EventType.BROKER_DISCONNECT: EventPriority.P0_CRITICAL,
    EventType.PRICE_TICK: EventPriority.P1_HIGH,
    EventType.ORDERBOOK_UPDATE: EventPriority.P1_HIGH,
    EventType.VOLUME_UPDATE: EventPriority.P1_HIGH,
    EventType.INDEX_UPDATE: EventPriority.P1_HIGH,
    EventType.VIX_UPDATE: EventPriority.P1_HIGH,
    EventType.ETEDA_CYCLE_START: EventPriority.P2_MEDIUM,
    EventType.STRATEGY_EVALUATE: EventPriority.P2_MEDIUM,
    EventType.RISK_EVALUATE: EventPriority.P2_MEDIUM,
    EventType.PORTFOLIO_EVALUATE: EventPriority.P2_MEDIUM,
    EventType.INDICATOR_UPDATE: EventPriority.P2_MEDIUM,
    EventType.SIGNAL_GENERATED: EventPriority.P2_MEDIUM,
    EventType.DASHBOARD_UPDATE: EventPriority.P3_LOW,
    EventType.LOG_WRITE: EventPriority.P3_LOW,
    EventType.REPORT_GENERATE: EventPriority.P3_LOW,
    EventType.NOTIFICATION_SEND: EventPriority.P3_LOW,
    EventType.METRIC_RECORD: EventPriority.P3_LOW,
}

@dataclass(frozen=True)
class Event:
    """이벤트 데이터 계약"""
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    event_type: EventType
    priority: EventPriority
    timestamp: datetime = field(default_factory=datetime.utcnow)
    source: str = ""
    payload: dict[str, Any] = field(default_factory=dict)
    requires_ack: bool = False
    max_process_time_ms: int = 0
    can_batch: bool = False
    can_collapse: bool = False
    can_drop: bool = False

class OverflowPolicy(str, Enum):
    """큐 오버플로우 정책"""
    BLOCK = "BLOCK"           # P0: 프로듀서 대기
    DROP_OLDEST = "DROP_OLDEST"  # P1: 가장 오래된 것 버림
    COLLAPSE = "COLLAPSE"     # P2: 같은 타입 병합
    SAMPLE = "SAMPLE"         # P3: 샘플링 (10%)

class DegradationLevel(str, Enum):
    """성능 저하 레벨"""
    NORMAL = "NORMAL"
    P3_PAUSED = "P3_PAUSED"
    P2_P3_PAUSED = "P2_P3_PAUSED"
    CRITICAL_ONLY = "CRITICAL_ONLY"
```

### 3.2 큐 구현 (`src/event/queue.py`)

```python
from abc import ABC, abstractmethod

class EventQueue(ABC):
    """이벤트 큐 추상 인터페이스"""

    @abstractmethod
    async def put(self, event: Event) -> bool: ...

    @abstractmethod
    async def get(self, timeout_ms: int = 0) -> Optional[Event]: ...

    @abstractmethod
    async def get_batch(self, max_count: int, timeout_ms: int) -> list[Event]: ...

    @abstractmethod
    def size(self) -> int: ...

    @abstractmethod
    def capacity(self) -> int: ...

    @abstractmethod
    def is_full(self) -> bool: ...

class BoundedQueue(EventQueue):
    """P0용: 고정 크기 블로킹 큐 (capacity=100)"""

class RingBuffer(EventQueue):
    """P1용: 링 버퍼, 오래된 것 드롭 (capacity=10000)"""

class CollapsingQueue(EventQueue):
    """P2용: 같은 타입 이벤트 병합 (capacity=1000)"""

class SamplingQueue(EventQueue):
    """P3용: 샘플링 큐 (max_capacity=50000, sample_rate=0.1)"""
```

### 3.3 디스패처 (`src/event/dispatcher.py`)

```python
class EventDispatcher:
    """이벤트 라우팅 및 핸들러 관리"""

    def __init__(self, config: EventConfig):
        self._queues: dict[EventPriority, EventQueue] = {}
        self._handlers: dict[EventPriority, list[EventHandler]] = {}
        self._degradation_level: DegradationLevel = DegradationLevel.NORMAL
        self._running: bool = False

    async def dispatch(self, event: Event) -> None:
        """이벤트를 적절한 큐로 라우팅"""

    async def start(self) -> None:
        """디스패처 시작 (각 우선순위별 컨슈머 태스크 생성)"""

    async def stop(self) -> None:
        """디스패처 종료 (graceful shutdown)"""

    def set_degradation_level(self, level: DegradationLevel) -> None:
        """성능 저하 레벨 설정"""

    def register_handler(self, priority: EventPriority, handler: EventHandler) -> None:
        """핸들러 등록"""
```

### 3.4 큐 설정 (`src/event/config.py`)

```python
@dataclass
class QueueConfig:
    priority: EventPriority
    capacity: int
    overflow_policy: OverflowPolicy
    batch_size: int = 1
    batch_timeout_ms: int = 0

QUEUE_CONFIGS = {
    EventPriority.P0_CRITICAL: QueueConfig(
        priority=EventPriority.P0_CRITICAL,
        capacity=100,
        overflow_policy=OverflowPolicy.BLOCK,
    ),
    EventPriority.P1_HIGH: QueueConfig(
        priority=EventPriority.P1_HIGH,
        capacity=10000,
        overflow_policy=OverflowPolicy.DROP_OLDEST,
        batch_size=100,
        batch_timeout_ms=10,
    ),
    EventPriority.P2_MEDIUM: QueueConfig(
        priority=EventPriority.P2_MEDIUM,
        capacity=1000,
        overflow_policy=OverflowPolicy.COLLAPSE,
        batch_size=50,
        batch_timeout_ms=100,
    ),
    EventPriority.P3_LOW: QueueConfig(
        priority=EventPriority.P3_LOW,
        capacity=50000,
        overflow_policy=OverflowPolicy.SAMPLE,
        batch_size=100,
        batch_timeout_ms=1000,
    ),
}

BACKPRESSURE_CONFIG = {
    EventPriority.P1_HIGH: {"warning": 0.70, "critical": 0.90},
    EventPriority.P2_MEDIUM: {"warning": 0.80, "critical": 0.95},
}
```

### 3.5 Safety 통합

- SafetyState.LOCKDOWN → DegradationLevel.CRITICAL_ONLY 자동 전환
- SafetyState.FAIL → DegradationLevel.P2_P3_PAUSED 자동 전환
- SafetyState.WARNING → DegradationLevel.P3_PAUSED 자동 전환
- SafetyState.NORMAL → DegradationLevel.NORMAL

```python
SAFETY_TO_DEGRADATION: dict[SafetyState, DegradationLevel] = {
    SafetyState.NORMAL: DegradationLevel.NORMAL,
    SafetyState.WARNING: DegradationLevel.P3_PAUSED,
    SafetyState.FAIL: DegradationLevel.P2_P3_PAUSED,
    SafetyState.LOCKDOWN: DegradationLevel.CRITICAL_ONLY,
}
```

## 4. System State Promotion Architecture 상세 설계

### 4.1 데이터 계약 (`src/state/contracts.py`)

```python
from dataclasses import dataclass
from enum import Enum
from typing import Optional
from datetime import datetime

class OperatingState(str, Enum):
    """운영 상태"""
    AGGRESSIVE = "AGGRESSIVE"
    BALANCED = "BALANCED"
    DEFENSIVE = "DEFENSIVE"

@dataclass(frozen=True)
class StateProperties:
    """각 운영 상태의 속성"""
    scalp_allocation_range: tuple[float, float]   # (min, max)
    swing_allocation_range: tuple[float, float]
    portfolio_allocation_range: tuple[float, float]
    risk_tolerance_multiplier: float
    entry_signal_threshold: float
    max_positions: int
    max_daily_trades: int
    rebalancing_enabled: bool
    new_entry_enabled: bool
    scalp_engine_active: bool
    swing_engine_active: bool

STATE_PROPERTIES: dict[OperatingState, StateProperties] = {
    OperatingState.AGGRESSIVE: StateProperties(
        scalp_allocation_range=(0.60, 0.80),
        swing_allocation_range=(0.15, 0.30),
        portfolio_allocation_range=(0.05, 0.10),
        risk_tolerance_multiplier=1.2,
        entry_signal_threshold=0.6,
        max_positions=20,
        max_daily_trades=50,
        rebalancing_enabled=False,
        new_entry_enabled=True,
        scalp_engine_active=True,
        swing_engine_active=True,
    ),
    OperatingState.BALANCED: StateProperties(
        scalp_allocation_range=(0.30, 0.50),
        swing_allocation_range=(0.30, 0.40),
        portfolio_allocation_range=(0.20, 0.30),
        risk_tolerance_multiplier=1.0,
        entry_signal_threshold=0.7,
        max_positions=15,
        max_daily_trades=30,
        rebalancing_enabled=True,
        new_entry_enabled=True,
        scalp_engine_active=True,
        swing_engine_active=True,
    ),
    OperatingState.DEFENSIVE: StateProperties(
        scalp_allocation_range=(0.05, 0.15),
        swing_allocation_range=(0.15, 0.25),
        portfolio_allocation_range=(0.60, 0.80),
        risk_tolerance_multiplier=0.5,
        entry_signal_threshold=0.9,
        max_positions=10,
        max_daily_trades=10,
        rebalancing_enabled=True,
        new_entry_enabled=False,
        scalp_engine_active=False,
        swing_engine_active=True,
    ),
}

@dataclass
class OperatingStateSnapshot:
    """운영 상태 스냅샷"""
    current_state: OperatingState
    previous_state: Optional[OperatingState]
    transition_timestamp: Optional[datetime]
    transition_reason: Optional[str]
    manual_override: bool
    override_expiry: Optional[datetime]
    state_duration_days: float
    properties: StateProperties

@dataclass
class TransitionMetrics:
    """상태 전환 판단에 사용되는 메트릭"""
    drawdown_pct: float
    vix: float
    consecutive_scalp_losses: int
    daily_loss_pct: float
    market_circuit_breaker: bool
    consecutive_profitable_days: int
    cagr: float
    target_cagr: float
    capital_growth_pct: float
    win_rate_30d: float

@dataclass
class ManualOverride:
    """수동 오버라이드"""
    override_state: OperatingState
    override_reason: str
    operator_id: str
    override_time: datetime
    expiry_time: datetime        # 최대 7일
    auto_revert_state: OperatingState
```

### 4.2 상태 전환 규칙 (`src/state/transition.py`)

```python
class TransitionRule(ABC):
    """상태 전환 규칙 추상 클래스"""
    @abstractmethod
    def evaluate(self, metrics: TransitionMetrics, safety_state: SafetyState,
                 state_duration_days: float) -> Optional[OperatingState]: ...

class AggressiveToBalanced(TransitionRule):
    """AGGRESSIVE → BALANCED (Any 조건 충족)"""
    # drawdown > 5% OR vix > 25 OR consecutive_scalp_losses > 5 OR daily_loss > 2%

class BalancedToDefensive(TransitionRule):
    """BALANCED → DEFENSIVE (Any 조건 충족)"""
    # drawdown > 10% OR vix > 30 OR market_circuit_breaker OR safety WARNING+

class DefensiveToBalanced(TransitionRule):
    """DEFENSIVE → BALANCED (All 조건 충족)"""
    # drawdown < 5% AND vix < 20 AND profitable_days >= 3 AND safety NORMAL AND 5일+

class BalancedToAggressive(TransitionRule):
    """BALANCED → AGGRESSIVE (All 조건 충족)"""
    # cagr > target AND vix < 15 AND growth > 10% AND win_rate > 60% AND 10일+

# Hysteresis 설정
HYSTERESIS_CONFIG = {
    OperatingState.AGGRESSIVE: {"min_duration_days": 7},
    OperatingState.BALANCED: {"min_duration_days": 5},
    OperatingState.DEFENSIVE: {"min_duration_days": 3},
}

COOLDOWN_HOURS = 24
CONFIRMATION_CYCLES = 2  # 조건 2시간 연속 유지
```

### 4.3 OperatingStateManager (`src/state/operating_state.py`)

```python
class OperatingStateManager:
    """운영 상태 관리자"""

    def __init__(self, config: StateConfig):
        self._state: OperatingState = OperatingState.BALANCED  # 기본값
        self._previous_state: Optional[OperatingState] = None
        self._transition_timestamp: Optional[datetime] = None
        self._override: Optional[ManualOverride] = None
        self._transition_rules: list[TransitionRule] = [...]
        self._pending_transition: Optional[tuple[OperatingState, int]] = None  # (state, cycle_count)

    @property
    def current_state(self) -> OperatingState: ...

    @property
    def properties(self) -> StateProperties: ...

    def evaluate_transition(self, metrics: TransitionMetrics, safety_state: SafetyState) -> Optional[OperatingState]:
        """전환 조건 평가 (Hysteresis + 쿨다운 + 2-cycle 확인 적용)"""

    def apply_override(self, override: ManualOverride) -> None:
        """수동 오버라이드 적용"""

    def check_override_expiry(self) -> None:
        """오버라이드 만료 확인 (7일 자동 만료)"""

    def get_snapshot(self) -> OperatingStateSnapshot:
        """현재 상태 스냅샷 반환"""
```

### 4.4 Safety State ↔ Operating State 통합

```
SafetyState (기존)                 OperatingState (신규)
─────────────────                  ─────────────────────
NORMAL ───────────────────────── 영향 없음
WARNING ──────────────────────── BALANCED/DEFENSIVE 전환 가능
FAIL ─────────────────────────── DEFENSIVE 강제 전환
LOCKDOWN ─────────────────────── 트레이딩 일시 중단 (상태 보존)
```

**우선순위**: Safety State > Operating State (항상)
- Safety가 LOCKDOWN이면 Operating State에 관계없이 모든 거래 중단
- LOCKDOWN 해제 시: AGGRESSIVE였으면 BALANCED로 보수적 복귀

## 5. 구현 순서

```
Step 1: 이벤트 계약 정의
  └── src/event/contracts.py, src/event/priority.py

Step 2: 큐 구현
  └── src/event/queue.py (BoundedQueue, RingBuffer, CollapsingQueue, SamplingQueue)

Step 3: 디스패처 구현
  └── src/event/dispatcher.py, src/event/handlers.py

Step 4: 운영 상태 계약 정의
  └── src/state/contracts.py, src/state/properties.py

Step 5: 전환 규칙 엔진
  └── src/state/transition.py

Step 6: OperatingStateManager
  └── src/state/operating_state.py, src/state/override.py

Step 7: Safety 통합
  └── src/event/dispatcher.py 수정 (Safety→Degradation 연동)
  └── src/state/operating_state.py 수정 (Safety→Operating 연동)

Step 8: 설정 및 모니터링
  └── src/event/config.py, src/event/monitoring.py
  └── src/state/config.py

Step 9: 테스트
  └── tests/unit/event/, tests/unit/state/
  └── tests/integration/event_state/
```

## 6. 테스트 전략

### 6.1 단위 테스트

| 대상 | 테스트 항목 | 파일 |
|------|-------------|------|
| EventPriority | enum 값, 매핑 정확성 | `tests/unit/event/test_contracts.py` |
| BoundedQueue | put/get, 블로킹, 오버플로우 | `tests/unit/event/test_queue.py` |
| RingBuffer | 링 버퍼 동작, DROP_OLDEST | `tests/unit/event/test_queue.py` |
| CollapsingQueue | 이벤트 병합 | `tests/unit/event/test_queue.py` |
| SamplingQueue | 샘플링 비율 | `tests/unit/event/test_queue.py` |
| EventDispatcher | 라우팅, 성능 저하 레벨 | `tests/unit/event/test_dispatcher.py` |
| OperatingState | enum 값, 속성 | `tests/unit/state/test_contracts.py` |
| TransitionRules | 각 전환 조건 | `tests/unit/state/test_transition.py` |
| Hysteresis | 최소 유지, 쿨다운, 2-cycle | `tests/unit/state/test_transition.py` |
| ManualOverride | 적용, 만료 | `tests/unit/state/test_override.py` |
| OperatingStateManager | 전환 통합 | `tests/unit/state/test_operating_state.py` |

### 6.2 통합 테스트

| 대상 | 테스트 항목 | 파일 |
|------|-------------|------|
| Safety→Degradation | 안전상태→이벤트 성능 저하 연동 | `tests/integration/test_safety_event.py` |
| Safety→Operating | 안전상태→운영상태 강제 전환 | `tests/integration/test_safety_state.py` |
| Event→Operating | 이벤트를 통한 상태 전환 트리거 | `tests/integration/test_event_state.py` |

## 7. 설정 파일 구조

### `config/event.yaml` (신규)
```yaml
event:
  queues:
    p0:
      capacity: 100
      overflow_policy: BLOCK
    p1:
      capacity: 10000
      overflow_policy: DROP_OLDEST
      batch_size: 100
      batch_timeout_ms: 10
    p2:
      capacity: 1000
      overflow_policy: COLLAPSE
      batch_size: 50
      batch_timeout_ms: 100
    p3:
      capacity: 50000
      overflow_policy: SAMPLE
      sample_rate: 0.1
      batch_size: 100
      batch_timeout_ms: 1000

  monitoring:
    check_interval_ms: 100
    alerts:
      p0_depth: {warning: 50, critical: 80}
      p1_depth: {warning: 7000, critical: 9000}
      p2_depth: {warning: 800, critical: 950}
```

### `config/state.yaml` (신규)
```yaml
operating_state:
  default: BALANCED
  hysteresis:
    aggressive: {min_duration_days: 7}
    balanced: {min_duration_days: 5}
    defensive: {min_duration_days: 3}
  cooldown_hours: 24
  confirmation_cycles: 2

  transitions:
    aggressive_to_balanced:
      drawdown_pct: 0.05
      vix: 25
      consecutive_scalp_losses: 5
      daily_loss_pct: 0.02
    balanced_to_defensive:
      drawdown_pct: 0.10
      vix: 30
    defensive_to_balanced:
      drawdown_pct: 0.05
      vix: 20
      consecutive_profitable_days: 3
      min_duration_days: 5
    balanced_to_aggressive:
      vix: 15
      capital_growth_pct: 0.10
      win_rate_30d: 0.60
      min_duration_days: 10

  override:
    max_duration_days: 7
```
