# Plan: QTS 아키텍처 고도화

> `docs/arch/sub/` 8개 서브 아키텍처 문서를 QTS에 구현하기 위한 통합 계획

## 1. 개요

### 1.1 목표
QTS의 `docs/arch/sub/` 폴더에 정의된 8개 서브 아키텍처를 단계적으로 구현하여,
현재 기본 ETEDA 파이프라인 + Google Sheets 기반 시스템을 프로덕션 수준의 고성능 트레이딩 시스템으로 고도화한다.

### 1.2 대상 문서

| # | 문서 | 핵심 내용 | 현재 구현율 |
|---|------|-----------|------------|
| 14 | Capital Flow Architecture | 3-Track 자금 풀 (Scalp/Swing/Portfolio), 승격/강등 | 0% |
| 15 | Scalp Execution Micro Architecture | 6-Stage 실행 파이프라인, 비동기 브로커 | ~5% |
| 16 | Micro Risk Loop Architecture | ETEDA 독립 100ms 리스크 루프 | ~10% |
| 17 | Event Priority Architecture | P0~P3 이벤트 우선순위 큐 | 0% |
| 18a | System State Promotion Architecture | AGGRESSIVE/BALANCED/DEFENSIVE 운영 상태 | 0% |
| 18b | Data Layer Architecture | PostgreSQL + TimescaleDB 마이그레이션 | 0% |
| 19 | Caching Architecture | Redis 캐싱 레이어 | 0% |
| 20 | Feedback Loop Architecture | 실행 품질 피드백, 슬리피지 학습 | 0% |

### 1.3 현재 상태 (As-Is)
- Safety Layer: **완전 구현** (NORMAL/WARNING/FAIL/LOCKDOWN)
- ETEDA Pipeline: **기본 구조** (stub executor, 시뮬레이션만)
- Risk: **기본 Gate** (calculated, staged)
- Data: **Google Sheets Only** (10+1 시트)
- Broker: **KIS/Kiwoom 어댑터** (기본)
- 이벤트/캐싱/자금관리: **미구현**

## 2. 구현 전략

### 2.1 핵심 원칙
1. **의존성 순서**: 하위 인프라 → 크로스커팅 → 비즈니스 로직 → 학습
2. **계약 우선**: 각 모듈의 Contract/Interface를 먼저 정의
3. **안전성 유지**: Safety Layer와의 통합을 항상 보장
4. **점진적 전환**: 기존 기능을 깨뜨리지 않는 단계적 마이그레이션
5. **테스트 주도**: 각 Phase마다 단위/통합 테스트 동반

### 2.2 Phase 구조

```
Phase 1: 크로스커팅 기반 (Event Priority + System State)
    ↓
Phase 2: 데이터 인프라 (Data Layer + Caching)
    ↓
Phase 3: 자금 관리 (Capital Flow)
    ↓
Phase 4: 실행 고도화 (Scalp Execution Micro)
    ↓
Phase 5: 실시간 리스크 (Micro Risk Loop)
    ↓
Phase 6: 학습 시스템 (Feedback Loop)
```

## 3. Phase 상세

### Phase 1: 크로스커팅 기반 (2주)

**대상 문서**: 17_Event_Priority + 18_System_State_Promotion

**근거**: 이벤트 우선순위와 운영 상태는 모든 후속 모듈이 의존하는 크로스커팅 관심사

#### Phase 1-A: Event Priority Architecture (17)
- **목표**: P0~P3 4단계 이벤트 우선순위 시스템
- **주요 구현**:
  - `src/event/` 패키지 생성
  - `EventPriority` enum (P0~P3)
  - `PriorityQueue` 각 레벨별 큐 (P0: bounded 100, P1: ring buffer 10000, P2: priority queue 1000, P3: unbounded 50000)
  - `EventDispatcher` 디스패처 (P0 전용 스레드, P1 풀(2), P2/P3 워커(4))
  - Overflow 정책 (P0: BLOCK, P1: DROP_OLDEST, P2: COLLAPSE, P3: SAMPLE)
  - 성능 저하 레벨 (NORMAL → P3_PAUSED → P2_P3_PAUSED → CRITICAL_ONLY)
- **레이턴시 목표**: P0 <10ms, P1 <50ms, P2 <500ms, P3 best-effort
- **Safety 통합**: 기존 SafetyState와 연동하여 LOCKDOWN 시 CRITICAL_ONLY 전환
- **테스트**: 큐 오버플로우, 우선순위 격리, 레이턴시 벤치마크

#### Phase 1-B: System State Promotion Architecture (18a)
- **목표**: 3가지 운영 상태 (AGGRESSIVE/BALANCED/DEFENSIVE) 관리
- **주요 구현**:
  - `src/state/` 패키지 생성 (기존 `src/safety/state.py`와 분리)
  - `OperatingState` enum + `OperatingStateManager`
  - 전환 조건: drawdown, VIX, 연속 손실 등 복합 판단
  - Hysteresis: 최소 유지 시간, 24시간 쿨다운, 2-cycle 확인
  - 수동 오버라이드 (7일 자동 만료)
  - Safety State와 직교적 관계 유지
- **엔진 통합**: Strategy, Portfolio, Risk, Capital 엔진에 OperatingState 입력 추가
- **테스트**: 상태 전환, 히스테리시스, 오버라이드 만료

### Phase 2: 데이터 인프라 (3주)

**대상 문서**: 18_Data_Layer + 19_Caching

**근거**: 고성능 데이터 접근이 후속 실행/리스크 모듈의 레이턴시 요건 충족에 필수

#### Phase 2-A: Data Layer Architecture (18b)
- **목표**: PostgreSQL + TimescaleDB로 마이그레이션 (Google Sheets 병행)
- **주요 구현**:
  - `DataSourceAdapter` 인터페이스 (추상 계층)
  - `TimescaleDBAdapter` 구현
  - `HybridAdapter` (이중 쓰기: Sheets + DB)
  - Hypertable: `tick_data` (1일 청크), `ohlcv_1d` (30일 청크), `execution_logs` (1일 청크)
  - Continuous Aggregates: `ohlcv_1m`, `daily_pnl`, `hourly_execution_metrics`
  - 보존 정책: tick_data 7일, execution_logs 90일
  - 마이그레이션 Phase 0~2: 스키마 생성, 이중 쓰기, 읽기 전환
- **계약**: 기존 `GoogleSheetsAdapter` 인터페이스 호환 유지
- **테스트**: 어댑터 계약 테스트, 이중 쓰기 일관성, 쿼리 성능

#### Phase 2-B: Caching Architecture (19)
- **목표**: Redis 캐싱 레이어로 핫 데이터 접근 가속
- **주요 구현**:
  - `src/cache/` 패키지 생성
  - `CacheManager` + `CacheClient` (Redis)
  - 6가지 캐시 타입: Price(100ms TTL), Position(1s), Orderbook(50ms), Risk(5s), Order(60s), Strategy(60s)
  - 캐시 패턴: Cache-Aside, Write-Through, Real-Time Push, Read-Through
  - Circuit Breaker (5회 실패 → 60초 복구)
  - Connection Pool (min 10, max 50, socket timeout 100ms)
- **목표 적중률**: Position >95%, Price >99%, Risk >90%
- **Fallback**: Redis 장애 시 DB 직접 조회
- **테스트**: 캐시 적중/미스, TTL 만료, Circuit Breaker, 장애 복구

### Phase 3: 자금 관리 (2주)

**대상 문서**: 14_Capital_Flow

**근거**: 실행 고도화 전에 자금 풀 분배 및 한도 관리가 선행되어야 함

- **목표**: 3-Track 자금 풀 관리 (Scalp/Swing/Portfolio)
- **주요 구현**:
  - `src/capital/` 패키지 생성
  - `CapitalPoolContract` 데이터 계약
  - `CapitalEngine` (6번째 엔진으로 추가)
  - 3-Track 풀: Scalp Pool, Swing Pool, Portfolio Pool
  - 승격 기준: accumulated_profit ≥ 1M, Sharpe > 1.5, WinRate > 55%
  - 강등 기준: MDD 트리거, 연속 손실
  - ETEDA Transform 단계에서 자금 한도 주입
  - OperatingState 연동 (AGGRESSIVE: Scalp 60~80%, DEFENSIVE: Portfolio 60~80%)
- **Safety 코드**: FS080~FS085, GR050~GR055
- **테스트**: 풀 분배, 승격/강등, 한도 초과, 안전 코드

### Phase 4: 실행 고도화 (2주)

**대상 문서**: 15_Scalp_Execution_Micro

**근거**: Capital Flow가 한도를 설정한 후, 실제 주문 실행을 고도화

- **목표**: ETEDA Act 단계를 6-Stage 실행 마이크로 파이프라인으로 확장
- **주요 구현**:
  - `src/execution/` 패키지 생성
  - 6 Stage: PreCheck → OrderSplit → AsyncSend → PartialFillMonitor → AdaptiveAdjust → EmergencyEscape
  - 실행 상태 머신: INIT → PRECHECK → SPLITTING → SENDING → MONITORING → ADJUSTING → ESCAPING → COMPLETE/ESCAPED/FAILED
  - `AsyncBrokerInterface`: send/modify/cancel/subscribe_fills
  - Multi-broker failover (KIS → Kiwoom)
  - Stage 타임아웃: PRECHECK 5s, SPLITTING 1s, SENDING 10s, MONITORING 60s
  - Redis PreCheck 캐싱 (<5ms 목표)
- **레이턴시**: PreCheck 2ms p50/5ms p99, 전체 100ms 이내
- **Safety 코드**: FS090~FS095, GR060~GR064
- **테스트**: 상태 전이, 타임아웃, failover, 부분 체결

### Phase 5: 실시간 리스크 (2주)

**대상 문서**: 16_Micro_Risk_Loop

**근거**: 실행 인프라 완성 후, 실시간 포지션 리스크 모니터링

- **목표**: ETEDA 독립적인 100ms~1s 주기 리스크 루프
- **주요 구현**:
  - `src/risk/micro_loop/` 패키지 생성
  - 4 컴포넌트: PositionShadowManager, PriceFeedHandler, RiskRuleEvaluator, ActionDispatcher
  - 4 규칙 (우선순위): VolatilityKillSwitch > MAE > TimeInTrade > TrailingStop
  - 6 액션: TRAILING_STOP_ADJUST, PARTIAL_EXIT, FULL_EXIT, POSITION_FREEZE, ETEDA_SUSPEND, KILL_SWITCH
  - Position Shadow: 100ms 동기화, 최대 100 포지션
  - P0 이벤트로 디스패치 (Event Priority 활용)
  - 목표: 사이클 당 20ms
- **Safety 코드**: FS100~FS105, GR070~GR074
- **테스트**: 규칙 우선순위, 액션 디스패치, 레이턴시, ETEDA 중단/재개

### Phase 6: 학습 시스템 (1주)

**대상 문서**: 20_Feedback_Loop

**근거**: 모든 실행 인프라 완성 후, 실행 품질 데이터 수집 및 학습

- **목표**: 실행 품질 피드백 수집 및 분석
- **주요 구현**:
  - `src/feedback/` 패키지 생성
  - `FeedbackData` 데이터 계약 (실행 메트릭, 마켓 컨텍스트, 학습 시그널)
  - 슬리피지 계산 (basis points)
  - Execution Quality Score (가중치: slippage 0.5, fill 0.3, latency 0.2)
  - Market Impact 추정 (Kyle's Lambda)
  - `FeedbackAggregator` 배치 잡 (1시간 주기)
  - `feedback_data` hypertable (180일 보존)
  - ML 통합 포인트 (슬리피지 예측)
- **테스트**: 스코어 계산, 집계, 데이터 보존

## 4. 의존성 그래프

```
Phase 1A (Event Priority) ─────────────────────────┐
    │                                                │
Phase 1B (System State) ─────┐                      │
    │                         │                      │
Phase 2A (Data Layer) ───────┤                      │
    │                         │                      │
Phase 2B (Caching) ──────────┤                      │
    │                         │                      │
Phase 3 (Capital Flow) ──────┤ (OperatingState)    │
    │                         │                      │
Phase 4 (Scalp Execution) ───┤ (Caching, Capital)  │ (Event Priority)
    │                         │                      │
Phase 5 (Micro Risk Loop) ───┤ (Execution)         │ (P0 Events)
    │                         │                      │
Phase 6 (Feedback Loop) ─────┘ (Data Layer, Execution)
```

## 5. 공통 패턴

### 5.1 패키지 구조 (신규 모듈 공통)
```
src/{module}/
├── __init__.py
├── contracts.py       # 데이터 계약 (dataclass)
├── interfaces.py      # 추상 인터페이스
├── {module}.py        # 핵심 구현
├── config.py          # 모듈 설정
└── exceptions.py      # 모듈 예외
```

### 5.2 Safety 통합 규칙
- 모든 신규 모듈은 Safety Layer와 통합
- FS(Fail-Safe), GR(Guardrail) 코드 등록
- LOCKDOWN 상태에서의 동작 정의 필수

### 5.3 테스트 전략
- 계약 테스트 → 단위 테스트 → 통합 테스트 순서
- `tests/unit/{module}/`, `tests/integration/{module}/`
- 각 Phase 완료 시 기존 테스트 회귀 확인

## 6. 리스크 및 완화

| 리스크 | 영향 | 완화 전략 |
|--------|------|-----------|
| Google Sheets → DB 마이그레이션 실패 | 데이터 손실 | HybridAdapter 이중 쓰기, 롤백 경로 확보 |
| Redis 장애 시 레이턴시 급증 | 실행 지연 | Circuit Breaker + DB Fallback |
| Safety State와 Operating State 충돌 | 잘못된 리스크 판단 | 직교적 설계, 명확한 우선순위 (Safety > Operating) |
| Phase 간 인터페이스 불일치 | 통합 실패 | Contract-First 접근, 인터페이스 선행 정의 |
| 레이턴시 목표 미달 | 실행 성능 저하 | 벤치마크 테스트를 Phase 1부터 수행 |

## 7. 성공 기준

- [ ] 각 Phase의 핵심 계약(Contract)이 정의되고 테스트 통과
- [ ] Safety Layer와의 통합 테스트 전체 통과
- [ ] 기존 테스트 회귀 없음
- [ ] 레이턴시 목표 달성 (P0 <10ms, PreCheck <5ms p99)
- [ ] 각 Phase에서 PDCA Check ≥ 90% Match Rate

## 8. 구현 순서 요약

| 순서 | Phase | 기간 | 핵심 산출물 |
|------|-------|------|-------------|
| 1 | Event Priority + System State | 2주 | `src/event/`, `src/state/` |
| 2 | Data Layer + Caching | 3주 | `src/db/timescale/`, `src/cache/` |
| 3 | Capital Flow | 2주 | `src/capital/` |
| 4 | Scalp Execution Micro | 2주 | `src/execution/` |
| 5 | Micro Risk Loop | 2주 | `src/risk/micro_loop/` |
| 6 | Feedback Loop | 1주 | `src/feedback/` |
| **합계** | | **12주** | 6개 신규 패키지 + 2개 확장 |
