# Design: 데이터 인프라 (Phase 2)

> Data Layer Adapter + Caching Layer 상세 설계

## 1. 아키텍처 개요

```
┌───────────────────────────────────────────────────────┐
│                    QTS Engine Layer                      │
│  (Strategy, Risk, Portfolio, Trading, Performance)       │
└──────────────────────┬──────────────────────────────────┘
                       │
         ┌─────────────▼─────────────┐
         │       CacheManager         │
         │  (Cache-Aside / Write-     │
         │   Through / Fallback)      │
         └──────┬────────────┬───────┘
                │            │
    ┌───────────▼──┐   ┌────▼──────────────┐
    │ CacheClient  │   │ DataSourceAdapter  │
    │ (interface)  │   │    (interface)     │
    └──────┬───────┘   └─────┬──────┬──────┘
           │                 │      │
    ┌──────▼───────┐  ┌─────▼──┐ ┌─▼──────────┐
    │InMemory/Redis│  │InMemory│ │TimescaleDB/ │
    │              │  │        │ │GoogleSheets │
    └──────────────┘  └────────┘ └─────────────┘
```

## 2. Data Layer 설계

### 2.1 데이터 계약 (src/db/contracts.py)

```python
@dataclass(frozen=True)
class Position:
    symbol: str
    qty: Decimal
    avg_price: Decimal
    market: str = ""
    exposure_value: Decimal = Decimal("0")
    exposure_pct: Decimal = Decimal("0")
    unrealized_pnl: Decimal = Decimal("0")
    updated_at: datetime | None = None

@dataclass(frozen=True)
class LedgerEntry:
    timestamp: datetime
    symbol: str
    side: Literal["BUY", "SELL"]
    qty: Decimal
    price: Decimal
    amount: Decimal
    fee: Decimal = Decimal("0")
    strategy_tag: str = ""
    order_id: str = ""
    broker: str = ""
    id: int | None = None  # DB auto-generated

@dataclass(frozen=True)
class OHLCV:
    time: datetime
    symbol: str
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: int

@dataclass(frozen=True)
class TickData:
    time: datetime
    symbol: str
    price: Decimal
    volume: int
    bid: Decimal | None = None
    ask: Decimal | None = None
    source: str = ""

@dataclass(frozen=True)
class HealthStatus:
    healthy: bool
    source: str
    latency_ms: float = 0.0
    error: str = ""
```

### 2.2 DataSourceAdapter 인터페이스 (src/db/adapters/interface.py)

```python
class DataSourceAdapter(ABC):
    @abstractmethod
    async def fetch_positions(self) -> list[Position]: ...

    @abstractmethod
    async def fetch_position(self, symbol: str) -> Position | None: ...

    @abstractmethod
    async def update_position(self, symbol: str, qty: Decimal, avg_price: Decimal) -> bool: ...

    @abstractmethod
    async def append_ledger(self, entry: LedgerEntry) -> bool: ...

    @abstractmethod
    async def fetch_ledger(
        self, symbol: str | None = None, start: datetime | None = None,
        end: datetime | None = None, limit: int = 100,
    ) -> list[LedgerEntry]: ...

    @abstractmethod
    async def fetch_ohlcv(
        self, symbol: str, start: datetime, end: datetime, interval: str = "1d",
    ) -> list[OHLCV]: ...

    @abstractmethod
    async def fetch_tick_data(
        self, symbol: str, start: datetime, end: datetime,
    ) -> list[TickData]: ...

    @abstractmethod
    async def health_check(self) -> HealthStatus: ...
```

### 2.3 InMemoryAdapter (src/db/adapters/memory.py)

- dict 기반 저장소
- 모든 CRUD 지원
- ohlcv/tick_data 시간 범위 필터링
- 테스트 및 로컬 개발용

### 2.4 TimescaleDBAdapter (src/db/adapters/timescale.py)

- asyncpg 기반 비동기 DB 접근
- Connection pool (min=5, max=20)
- 파라미터화된 쿼리 (SQL Injection 방지)
- Prepared statement 캐싱

### 2.5 HybridAdapter (src/db/adapters/hybrid.py)

- primary + secondary 어댑터 조합
- Write: 양쪽 동시 쓰기 (primary 실패 시 에러)
- Read: primary 우선, 실패 시 secondary fallback
- 일관성 검증 메서드 제공

### 2.6 설정 (src/db/adapters/config.py)

```python
class DataSourceMode(str, Enum):
    SHEETS_ONLY = "SHEETS_ONLY"
    HYBRID = "HYBRID"
    DB_ONLY = "DB_ONLY"

@dataclass(frozen=True)
class ConnectionPoolConfig:
    min_connections: int = 5
    max_connections: int = 20
    command_timeout: float = 5.0
    statement_cache_size: int = 100

@dataclass(frozen=True)
class DataLayerConfig:
    mode: DataSourceMode = DataSourceMode.SHEETS_ONLY
    db_dsn: str = ""
    pool: ConnectionPoolConfig = field(default_factory=ConnectionPoolConfig)
```

## 3. Caching Layer 설계

### 3.1 캐시 계약 (src/cache/contracts.py)

```python
class CacheType(str, Enum):
    PRICE = "price"           # 100ms TTL
    POSITION = "position"     # 1s TTL
    ORDERBOOK = "orderbook"   # 50ms TTL
    RISK = "risk"             # 5s TTL
    ORDER = "order"           # 60s TTL
    STRATEGY = "strategy"     # 60s TTL

CACHE_TTL: dict[CacheType, float] = {
    CacheType.PRICE: 0.1,
    CacheType.POSITION: 1.0,
    CacheType.ORDERBOOK: 0.05,
    CacheType.RISK: 5.0,
    CacheType.ORDER: 60.0,
    CacheType.STRATEGY: 60.0,
}

@dataclass(frozen=True)
class CacheStats:
    hit_count: int = 0
    miss_count: int = 0
    error_count: int = 0

    @property
    def hit_rate(self) -> float:
        total = self.hit_count + self.miss_count
        return self.hit_count / total if total > 0 else 0.0

@dataclass(frozen=True)
class CacheConfig:
    host: str = "localhost"
    port: int = 6379
    db: int = 0
    password: str = ""
    max_connections: int = 50
    socket_timeout_ms: int = 100
    socket_connect_timeout_ms: int = 500
    circuit_breaker_threshold: int = 5
    circuit_breaker_recovery_s: int = 60
```

### 3.2 CacheClient 인터페이스 (src/cache/interface.py)

```python
class CacheClient(ABC):
    @abstractmethod
    async def get(self, key: str) -> dict[str, str] | None: ...

    @abstractmethod
    async def set(self, key: str, mapping: dict[str, str], ttl: float) -> bool: ...

    @abstractmethod
    async def delete(self, key: str) -> bool: ...

    @abstractmethod
    async def get_many(self, keys: list[str]) -> dict[str, dict[str, str] | None]: ...

    @abstractmethod
    async def health_check(self) -> HealthStatus: ...
```

### 3.3 InMemoryCacheClient (src/cache/memory.py)

- dict[str, tuple[dict, float]] 기반 (값, 만료시각)
- get() 시 TTL 만료 확인 → 자동 제거
- Pipeline 지원 (배치 작업)
- 테스트용 time freeze 지원

### 3.4 RedisCacheClient (src/cache/redis_client.py)

- redis.asyncio 기반
- ConnectionPool 관리
- hset/hgetall 기반 Hash 작업
- Pipeline 지원 (배치 작업)
- Socket timeout = 100ms

### 3.5 Circuit Breaker (src/cache/circuit_breaker.py)

```
상태 전이:
  CLOSED ──(failures >= threshold)──→ OPEN
  OPEN ──(recovery_timeout 경과)──→ HALF_OPEN
  HALF_OPEN ──(success)──→ CLOSED
  HALF_OPEN ──(failure)──→ OPEN

설정:
  failure_threshold = 5
  recovery_timeout = 60s
```

```python
class CircuitState(str, Enum):
    CLOSED = "CLOSED"        # 정상 동작
    OPEN = "OPEN"            # 차단 (fallback)
    HALF_OPEN = "HALF_OPEN"  # 복구 시도

@dataclass
class CircuitBreaker:
    failure_threshold: int = 5
    recovery_timeout: float = 60.0
    state: CircuitState = CircuitState.CLOSED
    failure_count: int = 0
    last_failure_at: datetime | None = None

    def record_success(self) -> None: ...
    def record_failure(self) -> None: ...
    def can_execute(self) -> bool: ...
```

### 3.6 CacheManager (src/cache/manager.py)

중앙 캐시 관리자. Cache-Aside + Circuit Breaker 조합.

```python
class CacheManager:
    def __init__(self, client: CacheClient, db: DataSourceAdapter):
        self._client = client
        self._db = db
        self._breaker = CircuitBreaker()
        self._stats: dict[CacheType, CacheStats] = {}

    async def get_position(self, symbol: str) -> Position | None:
        """Cache-Aside: 캐시 → DB fallback"""
        ...

    async def update_position_on_fill(self, symbol: str, qty, avg_price) -> bool:
        """Write-Through: DB → 캐시 동시 업데이트"""
        ...

    async def get_price(self, symbol: str) -> dict | None:
        """Real-Time Push: 캐시에서만 조회 (miss = data unavailable)"""
        ...

    async def push_price(self, symbol: str, data: dict) -> bool:
        """Real-Time Push: 캐시에 직접 쓰기"""
        ...

    def get_stats(self, cache_type: CacheType) -> CacheStats: ...
    def is_circuit_open(self) -> bool: ...
```

## 4. 통합 설계

### 4.1 Event System 통합

| 이벤트 | 조건 | 우선순위 |
|--------|------|---------|
| METRIC_RECORD | 캐시 hit/miss 통계 | P3_LOW |
| BROKER_DISCONNECT | Circuit Breaker OPEN | P0_CRITICAL |

### 4.2 Safety 통합

| Safety State | Cache 동작 | DB 동작 |
|-------------|-----------|---------|
| NORMAL | 정상 | 정상 |
| WARNING | 정상 | 정상 |
| FAIL | Read-only | Read-only |
| LOCKDOWN | Flush + Disable | Read-only |

### 4.3 OperatingState 통합

CacheManager가 OperatingState에 따라 TTL 조정:
- AGGRESSIVE: Price TTL 50ms (더 빈번한 갱신)
- BALANCED: 기본 TTL
- DEFENSIVE: Position TTL 5s (보수적)

## 5. 구현 순서

```
1. src/db/contracts.py (데이터 계약)
2. src/db/adapters/ (interface → memory → config)
3. tests/unit/db/ (계약 + 어댑터 테스트)
4. src/cache/contracts.py (캐시 계약)
5. src/cache/ (interface → circuit_breaker → memory → manager)
6. tests/unit/cache/ (전체 캐시 테스트)
7. src/db/adapters/timescale.py (TimescaleDB)
8. src/db/adapters/hybrid.py (Hybrid)
9. tests/integration/ (통합 테스트)
```

## 6. 파일 목록

| 경로 | 설명 |
|------|------|
| `src/db/contracts.py` | Position, LedgerEntry, OHLCV, TickData, HealthStatus |
| `src/db/adapters/__init__.py` | 패키지 |
| `src/db/adapters/interface.py` | DataSourceAdapter ABC |
| `src/db/adapters/memory.py` | InMemoryAdapter |
| `src/db/adapters/timescale.py` | TimescaleDBAdapter |
| `src/db/adapters/hybrid.py` | HybridAdapter |
| `src/db/adapters/config.py` | DataSourceMode, ConnectionPoolConfig |
| `src/cache/__init__.py` | 패키지 |
| `src/cache/contracts.py` | CacheType, CacheStats, CacheConfig, CACHE_TTL |
| `src/cache/interface.py` | CacheClient ABC |
| `src/cache/memory.py` | InMemoryCacheClient |
| `src/cache/redis_client.py` | RedisCacheClient |
| `src/cache/circuit_breaker.py` | CircuitBreaker, CircuitState |
| `src/cache/manager.py` | CacheManager |
| `tests/unit/db/test_db_contracts.py` | 데이터 계약 테스트 |
| `tests/unit/db/test_adapters.py` | InMemoryAdapter 테스트 |
| `tests/unit/cache/test_cache_contracts.py` | 캐시 계약 테스트 |
| `tests/unit/cache/test_memory.py` | InMemoryCacheClient 테스트 |
| `tests/unit/cache/test_circuit_breaker.py` | CircuitBreaker 테스트 |
| `tests/unit/cache/test_manager.py` | CacheManager 테스트 |
| `tests/integration/test_data_cache.py` | DB+Cache+Event 통합 테스트 |
